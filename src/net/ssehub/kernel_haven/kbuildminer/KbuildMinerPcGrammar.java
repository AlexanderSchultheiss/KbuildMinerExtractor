/*
 * Copyright 2017-2019 University of Hildesheim, Software Systems Engineering
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.ssehub.kernel_haven.kbuildminer;

import net.ssehub.kernel_haven.util.logic.Formula;
import net.ssehub.kernel_haven.util.logic.Negation;
import net.ssehub.kernel_haven.util.logic.True;
import net.ssehub.kernel_haven.util.logic.parser.CStyleBooleanGrammar;
import net.ssehub.kernel_haven.util.logic.parser.ExpressionFormatException;
import net.ssehub.kernel_haven.util.logic.parser.Operator;
import net.ssehub.kernel_haven.util.logic.parser.VariableCache;
import net.ssehub.kernel_haven.util.null_checks.NonNull;
import net.ssehub.kernel_haven.util.null_checks.Nullable;

/**
 * A {@link Grammar} for parsing the presence conditions generated by KbuildMiner.
 * This generates the variables with CONFIG_ prefix.
 * 
 * <p>
 * Examples:
 * <ul>
 *      <li><code>((CRYPTO_AES_586 == "y") || (CRYPTO_AES_586 == "m"))</code></li>
 *      <li><code>((64BIT == "y") && ((CRYPTO_AES_NI_INTEL == "y") || (CRYPTO_AES_NI_INTEL == "m")))</code></li>
 *      <li><code>((X86_CMPXCHG64 != "y") && (X86_32 == "y"))</code></li>
 *      <li><code>!(X86_32 == "y")</code></li>
 *      <li><code>[TRUE]</code></li>
 * </ul>
 * </p>
 * 
 * @author Adam (from KernelMiner project)
 */
public class KbuildMinerPcGrammar extends CStyleBooleanGrammar {

    /**
     * Creates this grammar with the given variable cache. The cache is used
     * to create every single {@link Variable}, to ensure that no two different
     * {@link Variable} objects with the same variable name exist.
     * 
     * @param cache The cache to use, or <code>null</code>.
     */
    public KbuildMinerPcGrammar(@Nullable VariableCache cache) {
        super(cache);
    }
    
    @Override
    public Operator getOperator(char[] str, int it) {
        Operator result = null;
        
        if (str[it] == '!' && str[it + 1] != '=') {
            result = CStyleBooleanGrammar.NOT;
        }
        
        if (str[it] == '&' && str[it + 1] == '&') {
            result = CStyleBooleanGrammar.AND;
        }
        
        if (str[it] == '|' && str[it + 1] == '|') {
            result = CStyleBooleanGrammar.OR;
        }
        
        return result;
    }
    
    @Override
    public boolean isWhitespaceChar(char[] str, int it) {
        boolean result = false;
        
        if (super.isWhitespaceChar(str, it)) {
            // make sure that spaces around != and == don't interrupt the identifier
            
            result = true;
            
            if (it >= 2) {
                if (str[it - 1] == '=' && (str[it - 2] == '!' || str[it - 2] == '=')) {
                    result = false;
                }
            }
            if (it < str.length - 2) {
                if ((str[it + 1] == '!' || str[it + 1] == '=') && str[it + 2] == '=') {
                    result = false;
                }
            }
            
        }
        return result;
    }
    
    @Override
    public boolean isIdentifierChar(char[] str, int it) {
        // CHECKSTYLE:OFF
        // checkstyle thinks that this boolean formula is too complex;
        // but we need it this way because every other option is not as performant, and this
        // is a rather performance critical code path.
        return super.isIdentifierChar(str, it)
                || (str[it] == '!')
                || (str[it] == '=')
                || (str[it] == '"')
                || (str[it] == '[')
                || (str[it] == ']')
                || (str[it] == ' ');
        // CHECKSTYLE:ON
    }
    
    @Override
    public @NonNull Formula makeIdentifierFormula(String identifier) throws ExpressionFormatException {
        Formula result = null;
        
        if (identifier.contains("[") || identifier.contains("]")) {
            if (identifier.equals("[TRUE]")) {
                result = True.INSTANCE;
            } else {
                throw new ExpressionFormatException("Invalid identifier: " + identifier);
            }
        } else if (identifier.contains("==")) {
            identifier = identifier.replace(" =", "=").replace("= ", "=");
            
            int equalPos = identifier.indexOf('=');
            String varName = identifier.substring(0, equalPos);
            
            if (identifier.substring(equalPos + 2).equals("\"y\"")
                    || identifier.substring(equalPos + 2).equals("\"yes\"")) {
                result = super.makeIdentifierFormula("CONFIG_" + varName);
                
            } else if (identifier.substring(equalPos + 2).equals("\"m\"")) {
                result = super.makeIdentifierFormula("CONFIG_" + varName + "_MODULE");
                
            } else {
                throw new ExpressionFormatException("Invalid identifier: " + identifier);
            }
            
        } else if (identifier.contains("!=")) {
            result = new Negation(makeIdentifierFormula(identifier.replace('!', '=')));
            
        } else {
            if (!identifier.matches("[a-zA-Z0-9_]+")) {
                throw new ExpressionFormatException("Invalid identifier: " + identifier);
            }
            result = super.makeIdentifierFormula("CONFIG_" + identifier);
            
        }
        
        return result;
    }
    
}
